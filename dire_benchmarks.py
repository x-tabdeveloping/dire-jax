# -*- coding: utf-8 -*-
"""dire_benchmarks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PBoR4vKPk_ZNtpQuKpi8GkLD8Ojlc2_I

# Installs
"""

from google.colab import drive
drive.mount('/content/drive')

!pip3 install --upgrade pip

#
# FAISS has to be installed from conda: we need CondaColab
#
!pip install -q condacolab
import condacolab
condacolab.install()

#
# Install FAISS
#
!conda install pytorch::faiss-gpu

# Commented out IPython magic to ensure Python compatibility.
#
# cd to the DiRe install directory
#
# %cd drive/MyDrive/Colab\ Notebooks/DiRe-JAX

#
# Installing DiRe requirements
#
!pip install -r requirements_gpu.txt

#
# Doing some maintenance work (remove when becomes obsolete)
#
!pip install --upgrade cffi==1.17.1

#
# Benchmark-specific installs
#
!pip install CytofDR
!pip install PyCytoData
!pip install umap-learn
!git clone https://github.com/rapidsai/rapidsai-csp-utils.git
!python rapidsai-csp-utils/colab/pip-install.py

"""# Imports"""

# Commented out IPython magic to ensure Python compatibility.
#
# cd to the DiRe install directory
#
# %cd /content/drive/MyDrive/Colab Notebooks/DiRe-JAX

#
# Imports
#
from dire_jax.dire import *
from dire_jax.dire_utils import *
from jax import random
import numpy as np

#
# Benchmark-specific imports
#
from umap import UMAP
from cuml import UMAP as cUMAP
from cuml import TSNE as cTSNE
from PyCytoData import DataLoader

#
# Plotly settings: either interactive images or stills
#
import plotly.io as pio
#pio.renderers.default = 'colab' # interactive plots
pio.renderers.default = 'png'    # stills

#
# Suppress non-essential warnings
#
import warnings
warnings.filterwarnings('ignore', category=UserWarning)
warnings.filterwarnings('ignore', category=FutureWarning)
warnings.filterwarnings('ignore', category=DeprecationWarning)

"""# Benchmarking

## Dataset: "Blobs"

### DiRe reducer
"""

from sklearn.datasets import make_blobs
#
# Generate point blobs
#
n_samples  = 100_000
n_features = 1_000
n_centers  = 12
features_blobs, labels_blobs = make_blobs(n_samples=n_samples, n_features=n_features, centers=n_centers, random_state=42)
#

reducer_blobs = DiRe(dimension=2,
                     n_neighbors=16,
                     init_embedding_type='pca',
                     max_iter_layout=32,
                     min_dist=1e-4,
                     spread=1.0,
                     cutoff=4.0,
                     n_sample_dirs=8,
                     sample_size=16,
                     neg_ratio=32,
                     verbose=False,)

viz_benchmark(reducer_blobs,
              features_blobs,
              labels=labels_blobs,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=4)

"""### Defining benchmark dictionary"""

benchmarks_blobs = {}

benchmark = run_benchmark(reducer_blobs,
                          features_blobs,
                          labels=labels_blobs,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_blobs['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_blobs = cTSNE(n_components=2,
                   method='fft',
                   perplexity=reducer_blobs.n_neighbors,
                   n_neighbors=3*reducer_blobs.n_neighbors+1)
#
viz_benchmark(tred_blobs,
              features_blobs,
              labels=labels_blobs,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=4)

benchmark = run_benchmark(tred_blobs,
                          features_blobs,
                          labels=labels_blobs,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_blobs['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_blobs = cUMAP(n_components=reducer_blobs.dimension,
                    n_neighbors=reducer_blobs.n_neighbors,
                    min_dist=reducer_blobs.min_dist,
                    spread=reducer_blobs.spread)
#
viz_benchmark(cured_blobs,
              features_blobs,
              labels=labels_blobs,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=4)

benchmark = run_benchmark(cured_blobs,
                          features_blobs,
                          labels=labels_blobs,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_blobs['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_blobs = UMAP(n_components=reducer_blobs.dimension,
                 n_neighbors=reducer_blobs.n_neighbors,
                 min_dist=reducer_blobs.min_dist,
                 spread=reducer_blobs.spread)
#
viz_benchmark(red_blobs,
              features_blobs,
              labels=labels_blobs,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=4)

benchmark = run_benchmark(red_blobs,
                          features_blobs,
                          labels=labels_blobs,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_blobs['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Defining benchmark visualization procedure"""

import matplotlib.pyplot as plt

def plot_algorithm_comparison(data):
    """
    Plots comparison graphs for different algorithms based on their performance metrics.

    Parameters:
        data (dict): A dictionary where keys are algorithm names and values are dictionaries of metrics and distance metrics.
    """

    algorithms = list(data.keys())

    # Extracting data from the input dictionary
    embedding_time = [data[alg]['Embedding time'] for alg in algorithms]
    embedding_stress = [data[alg]['Embedding stress'] for alg in algorithms]
    neighborhood_preservation = [data[alg]['Neighborhood preservation score'] for alg in algorithms]
    context_preservation_svm = [data[alg]['Context preservation score (SVM)'] for alg in algorithms]
    context_preservation_knn = [data[alg]['Context preservation score (kNN)'] for alg in algorithms]

    # Distance metrics for dimension 0 and dimension 1
    dtw_dim0 = [data[alg]['Distance DTW for dimension 0'] for alg in algorithms]
    twed_dim0 = [data[alg]['Distance TWED for dimension 0'] for alg in algorithms]
    emd_dim0 = [data[alg]['Distance EMD for dimension 0'] for alg in algorithms]
    wasserstein_dim0 = [data[alg]['Distance Wasserstein for dimension 0'] for alg in algorithms]
    bottleneck_dim0 = [data[alg]['Distance bottleneck for dimension 0'] for alg in algorithms]

    dtw_dim1 = [data[alg]['Distance DTW for dimension 1'] for alg in algorithms]
    twed_dim1 = [data[alg]['Distance TWED for dimension 1'] for alg in algorithms]
    emd_dim1 = [data[alg]['Distance EMD for dimension 1'] for alg in algorithms]
    wasserstein_dim1 = [data[alg]['Distance Wasserstein for dimension 1'] for alg in algorithms]
    bottleneck_dim1 = [data[alg]['Distance bottleneck for dimension 1'] for alg in algorithms]

    # Normalize for the distance metrics relative to the first algorithm (assumed as reference)
    dtw_dim0_norm = np.array(dtw_dim0) / dtw_dim0[0] #np.log(np.array(dtw_dim0) / dtw_dim0[0])
    twed_dim0_norm = np.array(twed_dim0) / twed_dim0[0] #np.log(np.array(twed_dim0) / twed_dim0[0])
    emd_dim0_norm = np.array(emd_dim0) / emd_dim0[0] #np.log(np.array(emd_dim0) / emd_dim0[0])
    wasserstein_dim0_norm = np.array(wasserstein_dim0) / wasserstein_dim0[0] #np.log(np.array(wasserstein_dim0) / wasserstein_dim0[0])
    bottleneck_dim0_norm = np.array(bottleneck_dim0) / bottleneck_dim0[0] #np.log(np.array(bottleneck_dim0) / bottleneck_dim0[0])

    dtw_dim1_norm = np.array(dtw_dim1) / dtw_dim1[0] #np.log(np.array(dtw_dim1) / dtw_dim1[0])
    twed_dim1_norm = np.array(twed_dim1) / twed_dim1[0] #np.log(np.array(twed_dim1) / twed_dim1[0])
    emd_dim1_norm = np.array(emd_dim1) / emd_dim1[0] #np.log(np.array(emd_dim1) / emd_dim1[0])
    wasserstein_dim1_norm = np.array(wasserstein_dim1) / wasserstein_dim1[0] #np.log(np.array(wasserstein_dim1) / wasserstein_dim1[0])
    bottleneck_dim1_norm = np.array(bottleneck_dim1) / bottleneck_dim1[0] #np.log(np.array(bottleneck_dim1) / bottleneck_dim1[0])

    # Plotting the graphs
    fig, axs = plt.subplots(3, 2, figsize=(15, 15))

    # Embedding Time
    axs[0, 0].bar(algorithms, embedding_time, color='blue')
    axs[0, 0].set_title('Embedding Time (seconds)')
    axs[0, 0].set_ylabel('Time (s)')

    # Embedding Stress
    axs[0, 1].bar(algorithms, embedding_stress, color='green')
    axs[0, 1].set_title('Embedding Stress (Scaling Adjusted)')
    axs[0, 1].set_ylabel('Stress')

    # Neighborhood Preservation Score (Mean)
    axs[1, 0].bar(algorithms, neighborhood_preservation, color='orange')
    axs[1, 0].set_title('Neighborhood Preservation Score (Mean)')
    axs[1, 0].set_ylabel('Score')

    # Context Preservation Score (SVM and kNN)
    bar_width = 0.35
    index = np.arange(len(algorithms))

    axs[1, 1].bar(index, context_preservation_svm, bar_width, label='SVM', color='red')
    axs[1, 1].bar(index + bar_width, context_preservation_knn, bar_width, label='kNN', color='purple')
    axs[1, 1].set_title('Context Preservation Score (SVM and kNN)')
    axs[1, 1].set_ylabel('Score')
    axs[1, 1].set_xticks(index + bar_width / 2)
    axs[1, 1].set_xticklabels(algorithms)
    axs[1, 1].legend()

    # Plotting the normalized and log-transformed distance metrics for dimension 0
    axs[2, 0].plot(algorithms, dtw_dim0_norm, marker='o', label='DTW', color='blue')
    axs[2, 0].plot(algorithms, twed_dim0_norm, marker='o', label='TWED', color='green')
    axs[2, 0].plot(algorithms, emd_dim0_norm, marker='o', label='EMD', color='orange')
    axs[2, 0].plot(algorithms, wasserstein_dim0_norm, marker='o', label='Wasserstein', color='red')
    axs[2, 0].plot(algorithms, bottleneck_dim0_norm, marker='o', label='Bottleneck', color='purple')
    axs[2, 0].set_title('Normalized Distance Metrics for Dimension 0')
    axs[2, 0].set_ylabel('Distance Ratio')
    axs[2, 0].legend()

    # Plotting the normalized and log-transformed distance metrics for dimension 1
    axs[2, 1].plot(algorithms, dtw_dim1_norm, marker='o', label='DTW', color='blue')
    axs[2, 1].plot(algorithms, twed_dim1_norm, marker='o', label='TWED', color='green')
    axs[2, 1].plot(algorithms, emd_dim1_norm, marker='o', label='EMD', color='orange')
    axs[2, 1].plot(algorithms, wasserstein_dim1_norm, marker='o', label='Wasserstein', color='red')
    axs[2, 1].plot(algorithms, bottleneck_dim1_norm, marker='o', label='Bottleneck', color='purple')
    axs[2, 1].set_title('Normalized Distance Metrics for Dimension 1')
    axs[2, 1].set_ylabel('Distance Ratio')
    axs[2, 1].legend()

    plt.tight_layout()
    plt.show()

#
# Plot the benchmarking results
#
plot_algorithm_comparison(benchmarks_blobs)

"""## Dataset "MNIST Digits"
"""

from sklearn.datasets import fetch_openml
# Loading the full MNIST dataset
mnist = fetch_openml('mnist_784', version=1, parser='auto')
#
features_mnist = np.array(mnist['data'], dtype=np.float32)
labels_mnist = np.array(mnist['target'], dtype=np.int32)
#
features_mnist = features_mnist / 255.0 - 0.5

"""### DiRe reducer"""

reducer_mnist = DiRe(dimension=2,
                     n_neighbors=32,
                     init_embedding_type='spectral',
                     max_iter_layout=128,
                     min_dist=1e-4,
                     spread=1.0,
                     cutoff=8.0,
                     n_sample_dirs=4,
                     sample_size=32,
                     neg_ratio=16,
                     verbose=False,)

viz_benchmark(reducer_mnist,
              features_mnist,
              labels=labels_mnist,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmarks_mnist = {}

benchmark = run_benchmark(reducer_mnist,
                          features_mnist,
                          labels=labels_mnist,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_mnist['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_mnist = cTSNE(n_components=2,
                   method='fft',
                   perplexity=25,
                   n_neighbors=3*25+1)
#
viz_benchmark(tred_mnist,
              features_mnist,
              labels=labels_mnist,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_mnist,
                          features_mnist,
                          labels=labels_mnist,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_mnist['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_mnist = cUMAP(n_components=reducer_mnist.dimension,
                    n_neighbors=reducer_mnist.n_neighbors,
                    min_dist=reducer_mnist.min_dist,
                    spread=reducer_mnist.spread)
#
viz_benchmark(cured_mnist,
              features_mnist,
              labels=labels_mnist,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_mnist,
                          features_mnist,
                          labels=labels_mnist,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_mnist['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_mnist = UMAP(n_components=reducer_mnist.dimension,
                 n_neighbors=reducer_mnist.n_neighbors,
                 min_dist=reducer_mnist.min_dist,
                 spread=reducer_mnist.spread)
#
viz_benchmark(red_mnist,
              features_mnist,
              labels=labels_mnist,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_mnist,
                          features_mnist,
                          labels=labels_mnist,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_mnist['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_mnist)

"""## Dataset "Forest Cover Types"
"""

from sklearn.datasets import fetch_covtype
#
features_covtype, labels_covtype = fetch_covtype(return_X_y=True)
features_covtype, labels_covtype = features_covtype[::5], labels_covtype[::5]

"""### DiRe reducer"""

reducer_covtype  = DiRe(dimension=3,
                        n_neighbors=32,
                        init_embedding_type='pca',
                        max_iter_layout=64,
                        min_dist=1e-1,
                        spread=1.0,
                        cutoff=16.0,
                        n_sample_dirs=8,
                        sample_size=8,
                        neg_ratio=8,
                        verbose=False)

viz_benchmark(reducer_covtype,
              features_covtype,
              labels=labels_covtype,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmarks_covtype = {}

benchmark = run_benchmark(reducer_covtype,
                          features_covtype,
                          labels=labels_covtype,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_covtype['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_covtype = cTSNE(n_components=2,
                     method='fft',
                     perplexity=25,
                     n_neighbors=3*25+1)
#
viz_benchmark(tred_covtype,
              features_covtype,
              labels=labels_covtype,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_covtype,
                          features_covtype,
                          labels=labels_covtype,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_covtype['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_covtype = cUMAP(n_components=reducer_covtype.dimension,
                      n_neighbors=reducer_covtype.n_neighbors,
                      min_dist=reducer_covtype.min_dist,
                      spread=reducer_covtype.spread)
#
viz_benchmark(cured_covtype,
              features_covtype,
              labels=labels_covtype,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_covtype,
                          features_covtype,
                          labels=labels_covtype,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_covtype['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_covtype = UMAP(n_components=reducer_covtype.dimension,
                   n_neighbors=reducer_covtype.n_neighbors,
                   min_dist=reducer_covtype.min_dist,
                   spread=reducer_covtype.spread)
#
viz_benchmark(red_covtype,
              features_covtype,
              labels=labels_covtype,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_covtype,
                          features_covtype,
                          labels=labels_covtype,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_covtype['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_covtype)

"""## Dataset "Disk Uniform"
"""

def rand_point_disk(n, num=1):
  prepts = np.random.randn(num, n)
  prenorms = np.linalg.norm(prepts, axis=1).reshape(-1, 1)
  rads = np.sqrt(np.random.rand(num)).reshape(-1, 1)
  pts = prepts * rads/prenorms
  return pts

features_disk, labels_disk = rand_point_disk(2, 10000), None

"""### DiRe reducer"""

reducer_disk = DiRe(dimension=2,
                    n_neighbors=64,
                    init_embedding_type='pca',
                    max_iter_layout=16,
                    min_dist=1e-4,
                    spread=1.0,
                    cutoff=1.0,
                    n_sample_dirs=8,
                    sample_size=32,
                    neg_ratio=8,
                    verbose=False,)

viz_benchmark(reducer_disk,
              features_disk,
              labels=labels_disk,
              dimension=1,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmarks_disk = {}

benchmark = run_benchmark(reducer_disk,
                          features_disk,
                          labels=labels_disk,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_disk['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_disk = cTSNE(n_components=2,
                  method='fft',
                  perplexity=25,
                  n_neighbors=3*25+1)
#
viz_benchmark(tred_disk,
              features_disk,
              labels=labels_disk,
              dimension=1,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_disk,
                          features_disk,
                          labels=labels_disk,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_disk['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_disk = cUMAP(n_components=reducer_disk.dimension,
                   n_neighbors=reducer_disk.n_neighbors,
                   min_dist=reducer_disk.min_dist,
                   spread=reducer_disk.spread)
#
viz_benchmark(cured_disk,
              features_disk,
              labels=labels_disk,
              dimension=1,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_disk,
                          features_disk,
                          labels=labels_disk,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_disk['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_disk = UMAP(n_components=reducer_disk.dimension,
                n_neighbors=reducer_disk.n_neighbors,
                min_dist=reducer_disk.min_dist,
                spread=reducer_disk.spread)
#
viz_benchmark(red_disk,
              features_disk,
              labels=labels_disk,
              dimension=1,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_disk,
                          features_disk,
                          labels=labels_disk,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_disk['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_disk)

"""## Dataset "Sphere Uniform"
"""

def rand_point_sphere(n, num=1):
  prepts = np.random.randn(num, n)
  prenorms = np.linalg.norm(prepts, axis=1).reshape(-1, 1)
  pts = prepts/prenorms
  return pts

features_sphere, labels_sphere = rand_point_sphere(3, 10000), None

"""### DiRe reducer"""

reducer_sphere = DiRe(dimension=3,
                      n_neighbors=64,
                      init_embedding_type='pca',
                      max_iter_layout=32,
                      min_dist=1e-4,
                      spread=2.0,
                      cutoff=2.0,
                      n_sample_dirs=8,
                      sample_size=32,
                      neg_ratio=8,
                      verbose=False,)

viz_benchmark(reducer_sphere,
              features_sphere,
              labels=labels_sphere,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmarks_sphere = {}

benchmark = run_benchmark(reducer_sphere,
                          features_sphere,
                          labels=labels_sphere,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_sphere['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_sphere = cTSNE(n_components=2,
                    method='fft',
                    perplexity=25,
                    n_neighbors=3*25+1)
#
viz_benchmark(tred_sphere,
              features_sphere,
              labels=labels_sphere,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_sphere,
                          features_sphere,
                          labels=labels_sphere,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_sphere['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_sphere = cUMAP(n_components=reducer_sphere.dimension,
                     n_neighbors=reducer_sphere.n_neighbors,
                     min_dist=reducer_sphere.min_dist,
                     spread=reducer_sphere.spread)
#
viz_benchmark(cured_sphere,
              features_sphere,
              labels=labels_sphere,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_sphere,
                          features_sphere,
                          labels=labels_sphere,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_sphere['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_sphere = UMAP(n_components=reducer_sphere.dimension,
                  n_neighbors=reducer_sphere.n_neighbors,
                  min_dist=reducer_sphere.min_dist,
                  spread=reducer_sphere.spread)
#
viz_benchmark(red_sphere,
              features_sphere,
              labels=labels_sphere,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_sphere,
                          features_sphere,
                          labels=labels_sphere,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_sphere['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_sphere)

"""## Dataset "Ellipsoid Uniform"
"""

class elgen:
  def __init__(self, a):
    a = np.array(a)
    themat = np.diag(1/(a * a))
    L = np.linalg.inv(np.linalg.cholesky(themat).T)
    self.L = L

  def __call__(self, ar):
    return (self.L @ ar.T).T

def rand_point_ell(a, n, num=1):
  spts = rand_point_sphere(n, num)
  eg = elgen(a)
  return eg(spts)

features_ell, labels_ell = rand_point_ell([1,2,4], 3, 10000), None

"""### DiRe reducer"""

reducer_ell = DiRe(dimension=3,
                   n_neighbors=64,
                   init_embedding_type='pca',
                   max_iter_layout=64,
                   min_dist=1e-4,
                   spread=1.0,
                   cutoff=4.0,
                   n_sample_dirs=8,
                   sample_size=32,
                   neg_ratio=8,
                   verbose=False,)

viz_benchmark(reducer_ell,
              features_ell,
              labels=labels_ell,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmarks_ell = {}

benchmark = run_benchmark(reducer_ell,
                          features_ell,
                          labels=labels_ell,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_ell['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_ell = cTSNE(n_components=2,
                 method='fft',
                 perplexity=25,
                 n_neighbors=3*25+1)
#
viz_benchmark(tred_ell,
              features_ell,
              labels=labels_ell,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_ell,
                          features_ell,
                          labels=labels_ell,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_ell['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_ell = cUMAP(n_components=reducer_ell.dimension,
                  n_neighbors=reducer_ell.n_neighbors,
                  min_dist=reducer_ell.min_dist,
                  spread=reducer_ell.spread)
#
viz_benchmark(cured_ell,
              features_ell,
              labels=labels_ell,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_ell,
                          features_ell,
                          labels=labels_ell,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_ell['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_ell = UMAP(n_components=reducer_ell.dimension,
               n_neighbors=reducer_ell.n_neighbors,
               min_dist=reducer_ell.min_dist,
               spread=reducer_ell.spread)
#
viz_benchmark(red_ell,
              features_ell,
              labels=labels_ell,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_ell,
                          features_ell,
                          labels=labels_ell,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_ell['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': 0.0, # not computed
    'Context preservation score (kNN)': 0.0, # not computed
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_ell)

"""## Dataset "Two half-moons"
"""

from sklearn.datasets import make_moons
#
# Generate some sample data
#
n_samples  = 10_000
features_moons, labels_moons = make_moons(n_samples=n_samples, noise=0.005, random_state=42)

"""### DiRe reducer"""

reducer_moons = DiRe(dimension=2,
                     n_neighbors=64,
                     init_embedding_type='pca',
                     max_iter_layout=128,
                     min_dist=1e-4,
                     spread=1.0,
                     cutoff=8.0,
                     n_sample_dirs=16,
                     sample_size=16,
                     neg_ratio=16,
                     verbose=False,)

viz_benchmark(reducer_moons,
              features_moons,
              labels=labels_moons,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmarks_moons = {}

benchmark = run_benchmark(reducer_moons,
                          features_moons,
                          labels=labels_moons,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_moons['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_moons = cTSNE(n_components=2,
                   method='fft',
                   perplexity=25,
                   n_neighbors=3*25+1)
#
viz_benchmark(tred_moons,
              features_moons,
              labels=labels_moons,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_moons,
                          features_moons,
                          labels=labels_moons,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_moons['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_moons = cUMAP(n_components=reducer_moons.dimension,
                    n_neighbors=reducer_moons.n_neighbors,
                    min_dist=reducer_moons.min_dist,
                    spread=reducer_moons.spread)
#
viz_benchmark(cured_moons,
              features_moons,
              labels=labels_moons,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_moons,
                          features_moons,
                          labels=labels_moons,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_moons['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_moons = UMAP(n_components=reducer_moons.dimension,
                 n_neighbors=reducer_moons.n_neighbors,
                 min_dist=reducer_moons.min_dist,
                 spread=reducer_moons.spread)
#
viz_benchmark(red_moons,
              features_moons,
              labels=labels_moons,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_moons,
                          features_moons,
                          labels=labels_moons,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_moons['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_moons)

"""## Dataset "Levine 13"
"""

exprs_l13 = DataLoader.load_dataset(dataset = "levine13", force_download=True)
exprs_l13.preprocess(arcsinh=True)
##
mask = exprs_l13.cell_types!= 'unassigned'
##
features_l13 = exprs_l13.expression_matrix[mask,:]
labels_l13   = exprs_l13.cell_types[mask]

"""### DiRe reducer"""

reducer_l13 = DiRe(dimension=2,
                   n_neighbors=64,
                   init_embedding_type='pca',
                   max_iter_layout=64,
                   min_dist=1e-4,
                   spread=1.0,
                   cutoff=4.0,
                   n_sample_dirs=16,
                   sample_size=16,
                   neg_ratio=4,
                   verbose=False,)

viz_benchmark(reducer_l13,
              features_l13,
              labels=labels_l13,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmarks_l13 = {}

benchmark = run_benchmark(reducer_l13,
                          features_l13,
                          labels=labels_l13,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l13['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_l13 = cTSNE(n_components=2,
                  method='fft',
                  perplexity=25,
                  n_neighbors=3*25+1)
#
viz_benchmark(tred_l13,
              features_l13,
              labels=labels_l13,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_l13,
                          features_l13,
                          labels=labels_l13,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l13['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_l13 = cUMAP(n_components=reducer_l13.dimension,
                  n_neighbors=reducer_l13.n_neighbors,
                  min_dist=reducer_l13.min_dist,
                  spread=reducer_l13.spread)
#
viz_benchmark(cured_l13,
              features_l13,
              labels=labels_l13,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_l13,
                          features_l13,
                          labels=labels_l13,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l13['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

red_l13 = UMAP(n_components=reducer_l13.dimension,
               n_neighbors=reducer_l13.n_neighbors,
               min_dist=reducer_l13.min_dist,
               spread=reducer_l13.spread)
#
viz_benchmark(red_l13,
              features_l13,
              labels=labels_l13,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_l13,
                          features_l13,
                          labels=labels_l13,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l13['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_l13)

"""## Dataset "Levine 32"
"""

exprs_l32 = DataLoader.load_dataset(dataset = "levine32", force_download=True)
exprs_l32.preprocess(arcsinh=True)
##
mask = exprs_l32.cell_types!= 'unassigned'
##
features_l32 = exprs_l32.expression_matrix[mask,:]
labels_l32   = exprs_l32.cell_types[mask]

"""### DiRe reducer"""

reducer_l32 = DiRe(dimension=2,
                   n_neighbors=64,
                   init_embedding_type='random',
                   max_iter_layout=64,
                   min_dist=1e-4,
                   spread=1.0,
                   cutoff=4.0,
                   n_sample_dirs=16,
                   sample_size=16,
                   neg_ratio=16,
                   verbose=False,)

viz_benchmark(reducer_l32,
              features_l32,
              labels=labels_l32,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2,)

benchmarks_l32 = {}

benchmark = run_benchmark(reducer_l32,
                          features_l32,
                          labels=labels_l32,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l32['dire-jax'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML tSNE reducer"""

tred_l32 = cTSNE(n_components=2,
                  method='fft',
                  perplexity=25,
                  n_neighbors=3*25+1)
#
viz_benchmark(tred_l32,
              features_l32,
              labels=labels_l32,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(tred_l32,
                          features_l32,
                          labels=labels_l32,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l32['cuml-tsne'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### CuML UMAP reducer"""

cured_l32 = cUMAP(n_components=reducer_l32.dimension,
                  n_neighbors=reducer_l32.n_neighbors,
                  min_dist=reducer_l32.min_dist,
                  spread=reducer_l32.spread)
#
viz_benchmark(cured_l32,
              features_l32,
              labels=labels_l32,
              dimension=1,
              subsample_threshold=0.1,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(cured_l32,
                          features_l32,
                          labels=labels_l32,
                          dimension=1,
                          subsample_threshold=0.1,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l32['cuml-umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

"""### Original UMAP reducer"""

features_l32_sub = features_l32[::10]
labels_l32_sub   = labels_l32[::10]
#
red_l32 = UMAP(n_components=reducer_l32.dimension,
               n_neighbors=reducer_l32.n_neighbors,
               min_dist=reducer_l32.min_dist,
               spread=reducer_l32.spread)
#
viz_benchmark(red_l32,
              features_l32_sub,
              labels=labels_l32_sub,
              dimension=1,
              subsample_threshold=0.25,
              rng_key=random.PRNGKey(42),
              point_size=2)

benchmark = run_benchmark(red_l32,
                          features_l32_sub,
                          labels=labels_l32_sub,
                          dimension=1,
                          subsample_threshold=0.25,
                          rng_key=random.PRNGKey(42),
                          num_trials=1,
                          only_stats=True,)
#
#
#
benchmarks_l32['umap'] =  {
    'Embedding time': benchmark['timing'][0],
    'Embedding stress': benchmark['stress'][0],
    'Neighborhood preservation score': benchmark['neighbor'][0][0],
    'Context preservation score (SVM)': benchmark['svm'][0][2],
    'Context preservation score (kNN)': benchmark['knn'][0][2],
    'Distance DTW for dimension 0': benchmark['dtw'][0][0],
    'Distance TWED for dimension 0': benchmark['twed'][0][0],
    'Distance EMD for dimension 0': benchmark['emd'][0][0],
    'Distance Wasserstein for dimension 0': benchmark['wass'][0][0],
    'Distance bottleneck for dimension 0': benchmark['bott'][0][0],
    'Distance DTW for dimension 1': benchmark['dtw'][0][1],
    'Distance TWED for dimension 1': benchmark['twed'][0][1],
    'Distance EMD for dimension 1': benchmark['emd'][0][1],
    'Distance Wasserstein for dimension 1': benchmark['wass'][0][1],
    'Distance bottleneck for dimension 1': benchmark['bott'][0][1],
    }

plot_algorithm_comparison(benchmarks_l32)

